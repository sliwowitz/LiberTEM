
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>How does I/O work in LiberTEM? &#8212; LiberTEM 0.6.0.dev0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Acknowledgments" href="../acknowledgments.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="how-does-i-o-work-in-libertem">
<h1>How does I/O work in LiberTEM?<a class="headerlink" href="#how-does-i-o-work-in-libertem" title="Permalink to this headline">¶</a></h1>
<p>Many algorithms benefit from <a class="reference internal" href="../udf/advanced.html#tiled"><span class="std std-ref">Tiled processing</span></a> where the same subset in the signal
dimension is processed for several frames in a row. In many cases, algorithms
have specific minimum and maximum sizes in signal dimension, navigation
dimension or total size where they operate efficiently. Smaller sizes might
increase overheads, while larger sizes might reduce cache efficiency.</p>
<p>At the same time, file formats might operate well within specific size and
shape limits. The <a class="reference internal" href="../reference/dataset.html#k2is"><span class="std std-ref">K2IS</span></a> raw format is a prime example where data is saved
in tiled form and can be processed efficiently in specific tile sizes and
shapes that follow the native layout. Furthermore, some formats require
decoding or corrections by the CPU, such as <a class="reference internal" href="../reference/dataset.html#frms6"><span class="std std-ref">FRMS6</span></a>, where tiles that fit
the L3 cache can speed up subsequent processing steps. Requirements from the
I/O method such as alignment and efficient block sizes are taken into account
as well.</p>
<p>The LiberTEM I/O back-end negotiates a tiling scheme between UDF and dataset
that fulfills requirements from both UDF and dataset side as far as possible.
However, it is not always guaranteed that the supplied data will fall within
the requested limits.</p>
<div class="section" id="high-level-overview">
<h2>High-level overview<a class="headerlink" href="#high-level-overview" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Data is split into partitions which are read from independently. Usually
they split the navigation axis.</p></li>
<li><p>For each partition, the <code class="code docutils literal notranslate"><span class="pre">UDFRunner</span></code> negotiates a <code class="code docutils literal notranslate"><span class="pre">TilingScheme</span></code> using the
<code class="code docutils literal notranslate"><span class="pre">Negotiator</span></code> class</p></li>
<li><p>The <code class="code docutils literal notranslate"><span class="pre">TilingScheme</span></code> is then passed on to <code class="code docutils literal notranslate"><span class="pre">Partition.get_tiles</span></code>,
which then yields <code class="code docutils literal notranslate"><span class="pre">DataTiles</span></code> that match the given
<code class="code docutils literal notranslate"><span class="pre">TilingScheme</span></code>.</p></li>
<li><dl class="simple">
<dt>Under the hood, the <code class="code docutils literal notranslate"><span class="pre">Partition</span></code>…</dt><dd><ul>
<li><p>instantiates an <code class="code docutils literal notranslate"><span class="pre">IOBackend</span></code>, which has a reference to a <code class="code docutils literal notranslate"><span class="pre">Decoder</span></code></p></li>
<li><p>generates read ranges, which are passed on to the <code class="code docutils literal notranslate"><span class="pre">IOBackend</span></code></p></li>
<li><p>delegates <code class="code docutils literal notranslate"><span class="pre">get_tiles</span></code> to the <code class="code docutils literal notranslate"><span class="pre">IOBackend</span></code></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>The I/O process can be influenced by passing a subclass
of <code class="code docutils literal notranslate"><span class="pre">FileSet</span></code> to the <code class="code docutils literal notranslate"><span class="pre">Partition</span></code> and overriding <code class="code docutils literal notranslate"><span class="pre">FileSet.get_read_ranges</span></code>,
implementing a <code class="code docutils literal notranslate"><span class="pre">Decoder</span></code>, or even completely overriding
the <code class="code docutils literal notranslate"><span class="pre">Partition.get_tiles</span></code> functionality.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">IOBackend.get_tiles</span></code> has two modes of operation: either it reads the
tiles “straight” from the file, without copying or decoding, or it
uses the read ranges and copies/decodes the tiles in smaller units.</p></li>
<li><p>When reading the tiles “straight”, the read ranges are not used, instead
only the slice information for each tile is used. That also means that this
mode only works for very simple formats, when reading without a <code class="code docutils literal notranslate"><span class="pre">roi</span></code>
and when not doing any <code class="code docutils literal notranslate"><span class="pre">dtype</span></code> conversion or decoding.</p></li>
</ul>
<div class="section" id="read-ranges">
<h3>Read ranges<a class="headerlink" href="#read-ranges" title="Permalink to this headline">¶</a></h3>
<p>In <code class="code docutils literal notranslate"><span class="pre">FileSet.get_read_ranges</span></code>, the reading parameters (TilingScheme, roi etc.)
are translated into one or more byte ranges (offset, length) for each tile.
You can imagine it as translating pixel/element positions into byte offsets.</p>
<p>Each range corresponds to a read operation on a single file, which means read
ranges for a single tile can correspond to reads from multiple files. This
is important when reading from a data set with many small files - we can
still generate tiles for efficient processing.</p>
<p>There are some built-in common parameters in <cite>FileSet</cite>, like
<cite>frame_header_bytes</cite>, <cite>frame_footer_bytes</cite>, which can be used to easily
implement formats where the reading just needs to skip a few bytes for each
frame header/footer.</p>
<p>If you need more influence over how data is read, you can override
<cite>FileSet.get_read_ranges</cite> and return your own read ranges. You can use
the <cite>make_get_read_ranges</cite> function to re-use much of the tiling logic,
or implement this yourself. Using <cite>make_get_read_ranges</cite> you can either
override just the <cite>px_to_bytes</cite> part, or <cite>read_ranges_tile_block</cite> for whole
tile blocks. This is done by passing in njit-ed functions to <cite>make_get_read_ranges</cite>.
<cite>make_get_read_ranges</cite> should only be called on module-level to enable
caching of the numba compilation.</p>
<p>Read ranges are generated as an array with the following shape:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">number_of_tiles</span><span class="p">,</span> <span class="n">rr_per_tile</span><span class="p">,</span> <span class="n">rr_num_entries</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">rr_per_tile</span></code> here is the maximum number of read ranges per tile - there
can be tiles that are smaller than this, for example at the end of a partition.
<code class="code docutils literal notranslate"><span class="pre">rr_num_entries</span></code> is at least 3 and contains at least the values
<code class="code docutils literal notranslate"><span class="pre">(file_idx,</span> <span class="pre">start,</span> <span class="pre">stop)</span></code>. This means to read <code class="code docutils literal notranslate"><span class="pre">stop</span> <span class="pre">-</span> <span class="pre">start</span></code>
bytes, beginning at offset <code class="code docutils literal notranslate"><span class="pre">start</span></code>, from the file <code class="code docutils literal notranslate"><span class="pre">file_idx</span></code>
in the corresponding <code class="code docutils literal notranslate"><span class="pre">FileSet</span></code>.</p>
<p>Overriding <code class="code docutils literal notranslate"><span class="pre">DataSet</span></code>s are free to add additional fields to the end, for
example if the decoding functions need additional information.</p>
<p>As an example when you would generate custom read ranges, have a look at the
implementations for MIB, K2IS, and FRMS6 - they may not have a direct 1:1 mapping
to a numpy <code class="code docutils literal notranslate"><span class="pre">dtype</span></code>, or the pixels may need to be re-ordered after decoding.</p>
</div>
</div>
<div class="section" id="notes-for-implementing-a-dataset">
<h2>Notes for implementing a <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.DataSet" title="libertem.io.dataset.base.DataSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataSet</span></code></a><a class="headerlink" href="#notes-for-implementing-a-dataset" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Read file header(s) in <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.DataSet.initialize" title="libertem.io.dataset.base.DataSet.initialize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">initialize()</span></code></a> -
make sure to do the actual I/O in a function dispatched via the
<code class="code docutils literal notranslate"><span class="pre">JobExecutor</span></code> that is passed to <code class="code docutils literal notranslate"><span class="pre">initialize</span></code>.
See also <a class="reference internal" href="../tips.html#os-mismatch"><span class="std std-ref">Platform-dependent code and remote executor</span></a> regarding platform-dependent code.</p></li>
<li><p>Implement <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.DataSet.check_valid" title="libertem.io.dataset.base.DataSet.check_valid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check_valid()</span></code></a> - this will
be run on a worker node</p></li>
<li><p>Implement <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.DataSet.get_msg_converter" title="libertem.io.dataset.base.DataSet.get_msg_converter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_msg_converter()</span></code></a> - the
<code class="xref py py-class docutils literal notranslate"><span class="pre">MessageConverter</span></code> class returned is responsible
for parsing parameters passed to the Web API and converting them to a Python
representation that can be passed to the
<a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.DataSet" title="libertem.io.dataset.base.DataSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataSet</span></code></a> constructor.</p></li>
<li><p>Implement <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.DataSet.get_cache_key" title="libertem.io.dataset.base.DataSet.get_cache_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_cache_key()</span></code></a> - the cache
key must be different for <code class="code docutils literal notranslate"><span class="pre">DataSet</span></code>s that return different data.</p></li>
<li><p>Implement <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.DataSet.get_partitions" title="libertem.io.dataset.base.DataSet.get_partitions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_partitions()</span></code></a>. You may
want to use the helper function
<code class="xref py py-meth docutils literal notranslate"><span class="pre">make_slices()</span></code> to generate
slices for a specified number of partitions.
<a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.DataSet.get_partitions" title="libertem.io.dataset.base.DataSet.get_partitions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_partitions()</span></code></a> should yield either
<a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.BasePartition" title="libertem.io.dataset.base.BasePartition"><code class="xref py py-class docutils literal notranslate"><span class="pre">BasePartition</span></code></a> instances or instances of
your own subclass (see below). The same is true for the
<a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.FileSet" title="libertem.io.dataset.base.FileSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileSet</span></code></a> that is passed to each
partition - you possibly have to implement your own subclass.</p></li>
</ul>
<div class="section" id="subclass-basepartition">
<h3>Subclass <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.BasePartition" title="libertem.io.dataset.base.BasePartition"><code class="xref py py-class docutils literal notranslate"><span class="pre">BasePartition</span></code></a><a class="headerlink" href="#subclass-basepartition" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Implement <code class="xref py py-meth docutils literal notranslate"><span class="pre">_get_decoder()</span></code> to return
an instance of <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.Decoder" title="libertem.io.dataset.base.Decoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decoder</span></code></a>. Only needed if
the data is saved in a data type that is not directly understood by numpy
or numba. See below for details.</p></li>
<li><p>Implement <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.BasePartition.get_base_shape" title="libertem.io.dataset.base.BasePartition.get_base_shape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_base_shape()</span></code></a>. This
is only needed if the data format imposes any constraints on how the data can be
read in an efficient manner, for example if data is saved in blocks. The tileshape
that is negotiated before reading will be a multiple of the base shape in
all dimensions.</p></li>
<li><p>Implement <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.BasePartition.adjust_tileshape" title="libertem.io.dataset.base.BasePartition.adjust_tileshape"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjust_tileshape()</span></code></a>. This
is needed if you need to “veto” the generated tileshape, for example if your dataset
has constraints that can’t be expressed by the base shape.</p></li>
<li><p>Override <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.BasePartition.get_tiles" title="libertem.io.dataset.base.BasePartition.get_tiles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_tiles()</span></code></a> if you need to
use completely custom I/O logic.</p></li>
</ul>
</div>
<div class="section" id="implementing-a-decoder">
<h3>Implementing a <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.Decoder" title="libertem.io.dataset.base.Decoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decoder</span></code></a><a class="headerlink" href="#implementing-a-decoder" title="Permalink to this headline">¶</a></h3>
<p>This may be needed if the raw data is not directly supported
by numpy or numba. Mostly your decoder will return a different
<code class="code docutils literal notranslate"><span class="pre">decode</span></code> function in <a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.Decoder.get_decode" title="libertem.io.dataset.base.Decoder.get_decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_decode()</span></code></a>.
You can also return different decode functions, depending on the
concrete data set you are currently reading. For example, this may be needed if there
are different data representations generated by different detector modes.
You can also instruct the <code class="code docutils literal notranslate"><span class="pre">IOBackend</span></code> to clear the read
buffer before calling <code class="code docutils literal notranslate"><span class="pre">decode</span></code> by returning <code class="code docutils literal notranslate"><span class="pre">True</span></code> from
<a class="reference internal" href="../reference/dataset.html#libertem.io.dataset.base.Decoder.do_clear" title="libertem.io.dataset.base.Decoder.do_clear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_clear()</span></code></a>. This can be needed
if different read ranges contribute to the same part of the output buffer
and the <code class="code docutils literal notranslate"><span class="pre">decode</span></code> function accumulates into the buffer instead of slice-assigning.</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">decode</span></code> function will be called for each read range that was
generated by the <code class="code docutils literal notranslate"><span class="pre">get_read_ranges</span></code> method described above.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">GUI usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../formats.html">Loading data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../udf.html">User-defined functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../packages.html">Package overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sample_datasets.html">Sample Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance.html">Performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tips.html">Tips and tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../why_python.html">Why Python?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gsoc.html">GSoC 2020 ideas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authorship.html">Authorship policy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../acknowledgments.html">Acknowledgments</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">How does I/O work in LiberTEM?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#high-level-overview">High-level overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#notes-for-implementing-a-dataset">Notes for implementing a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataSet</span></code></a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../acknowledgments.html" title="previous chapter">Acknowledgments</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, LiberTEM Authors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/dev/how-io-works.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>